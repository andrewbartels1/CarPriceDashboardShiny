---
title: "Model Comparison"
author: "Jason Young"
date: "4/23/2022"
output: html_document
---

### Contents of this Workbook
1. Setup

2. Define the the Model_Comparision() Function

3. Demo the Model_Comparision() Function
  3.a. Create a Sample Dataframe
  3.b. Create 3 Sample Model-Creation Functions
  3.c. Run Model_Comparison() on the sample data and display comparison table
  
4. Model_Comparison is applied to Matt and Angie's models


#### 1. Setup
Clear Enviromnet & Load Libraries 

```{r}
rm(list = ls()) # Clear Enviromnemt
library(tidyverse)
library(dplyr)
library(readxl) 
library(stringr) # string formatting
library(RSQLite) # to connect to SQlite database
library(glmnet)
```

### 2. Define the Model_Comparison() Function
Takes 1 dataframe and any number of models to compare
Splits the datframe into train, validation, and test sets
Trains each model on the training data
Compares each model using the validation data and selects the best one
Evaluates the best model with the test set
Prints a dataframe comparing accuracy metrics

    the funtion takes 2 arguments
      1st arg is the data frame to be used for train/test/validate
      
      2nd arg is a list of lists where:
        the first entry is a string "model_name"
        the second entry is a function to build the model from the data frame
      
      For Example:
        
        Model_Comparison( cars_df,
                          [ ("LM #1", model_creation_function() ),  
                            ("LM #2", model_creation_function() ), 
                            ("KNN #1", model_creation_function() 
                          ]
                        )  
    


```{r}
Model_Comparison <- function(df, list_of_tuples)
{  
  # split dataframe into training, validation, and test sets (60-20-20% rule)         
  train_size = round(0.6 * nrow(df), 0)
  valid_size = round(0.2 * nrow(df), 0)
  test_size = round(0.2 * nrow(df), 0)
  shuffled_rows <- sample(nrow(df)) 
  df = df[shuffled_rows, ]
  train_data = df[1:train_size, ]
  valid_data = df[(train_size + 1):(train_size + valid_size), ] 
  test_data = df[(train_size + valid_size + 1):nrow(df), ]
  
  # Create the empty output dataframe for comparison
  output_df <- data.frame(matrix(ncol = 4, nrow = 0))
  colnames(output_df) <- c("Model", "R^2 on Validation Data", "Best Model?", "R^2 on Test Data")
  
  # Create empty lists to collect R^2 values
  R_2_list = c()
  best_R_2_list = c()
  
  # For each model provided:
  for (i in 1:length(list_of_tuples))
  {
    # Use training set to create the model
    mod = tuple_list[[i]][[2]](train_data)
  
    # Use the model to predict values on the validation set and collect the SSE in a list
    predictions = predict(mod, valid_data)
    SSR = sum((predictions - valid_data$price)^2)
    SST = sum((valid_data$price - mean(valid_data$price))^2)
    R_2 = 1 - SSR/SST
    R_2_list = c(R_2_list, R_2)
    
    # Use model to predict values on the test set (used for the final selected model)
    predictions = predict(mod, test_data)
    SSR = sum((predictions - test_data$price)^2)
    SST = sum((test_data$price - mean(test_data$price))^2)
    R_2 = 1 - SSR/SST
    best_R_2_list = c(best_R_2_list, R_2)
    
  }
  
  # Determine the best model, based on smallest SSE on the validation set
  best = which(R_2_list == max(R_2_list))
  best_R_2 = rep(0, length(list_of_tuples))
  best_R_2[[best]] = 1
  
  
  # Report Test Accuracy for best model
  test_acc = c()
  for (i in 1:length(list_of_tuples))
  {
    if (best_R_2[[i]] == 0){
      test_acc = c(test_acc, NA)}
    else{
      test_acc = c(test_acc, best_R_2_list[[i]])
    }
  }
  
  # Populate the final output dataframe, using values collected above
  #   and print it
  for (i in 1:length(list_of_tuples))
  {
  output_df[nrow(output_df) + 1,] = c(tuple_list[[i]][[1]], #Name Column
                                      R_2_list[[i]],  #SSE on Validation
                                      best_R_2[[i]],  #1=best model, 0=all others
                                      test_acc[[i]])
  }
  print(output_df)
  
}  



```



### 3. Demo the Model_Comparision() Function:


### 3.a. Create Sample Dataframe
The code block below creates a dataframe called cars_new from the CraigslistCarsClean.sqlite3
The specifics of this df are not important, it is only used as a demo
and other dataframe could be used


```{r}
# SQLite Connection
# Using Matt's cleaned tables
db_path <- "CraigslistCarsClean.sqlite3"
conn <- dbConnect(RSQLite::SQLite(), db_path)
dbListTables(conn)

#------------------------------------------------------------------------------
# Step 1: Create a simple dataframe to use for modeling and varible selection
#------------------------------------------------------------------------------

# Join the Percent of Employment Attributable to Outdoor Rec to the main cars table
query = '
  SELECT A.*
    ,B.[Percent of total wage and salary employment1]
    ,B.[Percent of total compensation1]
  FROM cars_clean A
  LEFT JOIN outdoor_rec_by_state B
    ON A.state = B.State
'
cars <- dbGetQuery(conn, query)
dbDisconnect(conn)
#rename new columns
names(cars)[names(cars) == 'Percent of total wage and salary employment1'] <- 'perc_outdoor_employment'
names(cars)[names(cars) == 'Percent of total compensation1'] <- 'perc_total_comp'

# Create a new column for how old the car is (in years)
cars$age = (2021 - cars$year)

# Create a binary variable for title status
cars$has_clean_title = ifelse(cars$title_status == 'clean', 1, 0)

# filter out cars where price too big/small
max_price = 100000
min_price = 1000
cars_new = 
  cars %>% 
    filter((price > min_price) & (price < max_price)) %>% 
    select(price, perc_outdoor_employment, perc_total_comp, age, has_clean_title)
nrow(cars) # = 400870 rows
nrow(cars_new) # = 359537 rows
head(cars_new)
```


### 3.b. Create Sample Model Functions


```{r, echo=FALSE}

model_1_function = function(df)
{
  model <- lm(as.numeric(price) ~ perc_outdoor_employment + age + has_clean_title, data=df)
  return (model)
}

model_2_function = function(df)
{
  model <- lm(as.numeric(price) ~ log(perc_outdoor_employment) + age + has_clean_title, data=df)
  return (model)
}

model_3_function = function(df)
{
  model <- lm(as.numeric(price) ~ has_clean_title, data=df)
  return (model)
}


# Create a list of tuples in the format required by Model_Comparison()

tuple_list =
  list(
    list("Model 1", model_1_function),
    list("Model 2", model_2_function),
    list("Model 3_bad", model_3_function)
  )


```


### 3.c. Run Model_Comparison() on the sample data


```{r}
# Run the function on sample data and models (created in the code cells below)
Model_Comparison(cars_new, tuple_list)
```


### 4. Apply Model_Comparison to the same data from Models_Matt.R


### First, replicate the dataframe used

```{r}
# Create Path to SQLite db

db_path <- "CraigslistCarsClean.sqlite3"

# Establish connection
conn <- dbConnect(RSQLite::SQLite(), db_path)
cars <- dbGetQuery(conn, "SELECT * FROM Ford")

# Close db connection
dbDisconnect(conn)

Add_Regions <- function (df) {
  
  # Create 9 different regions of the country
  southwest <- c("CA", "AZ", "NM", "HI","NV")
  west <- c("UT", "CO", "WY", "MT", "ND", "SD")
  pnw <- c("AK", "OR", "ID", "WA")
  n_east <- c("CT", "ME", "MA", "NH", "RI", "VT")
  east <- c("NJ", "NY", "DE", "MD", "PA", "VA", "DC", "WV")
  s_east <- c("AL", "FL", "GA", "KY", "MS", "NC", "SC", "TN")
  midwest <- c("IL", "IN", "MI", "MN", "OH", "WI")
  south <- c("TX", "AR", "LA", "OK")
  central <- c("IA", "KS", "MO", "NE")
  
  # Add Regions to cars DF
  df <- df %>%
    mutate(region = case_when(state %in% southwest ~ "Southwest", 
                              state %in% west ~ "West",
                              state %in% pnw ~ "Pacific Northwest",
                              state %in% n_east ~ "Northeast",
                              state %in% east ~ "East",
                              state %in% s_east ~ "Southeast",
                              state %in% midwest ~ "Midwest",
                              state %in% south ~ "South",
                              state %in% central ~ "Central"
                              )
           )
  
 return(df) 
  
}

# Add regions to 'cars' df
cars <- Add_Regions(cars)


Clean_Drive <- function(df){
  awd <- paste(c("awd", "awD", "Awd", "AwD", "AWD"), collapse = "|")
  rwd <- paste(c("rwd", "RwD", "Rwd", "rwD", "RWD"), collapse = "|")
  fwd <- paste(c("fwd", "FwD", "fWD", "fwD", "FWD", "Fwd"), collapse = "|")
  fourwheeldrive <- paste(c("4wd", "4wD", "4WD", "4wD", "4Wd"), collapse = "|")
  
  df$drive <- str_replace_all(df$drive, regex(pattern = awd), "AWD")
  df$drive <- str_replace_all(df$drive, regex(pattern = rwd), "RWD")
  df$drive <- str_replace_all(df$drive, regex(pattern = fwd), "FWD")
  df$drive <- str_replace_all(df$drive, regex(pattern = fourwheeldrive), "4WD")
  
  return(df)
}

##------------------------------------
##  Test Clean_Drive() Function  --
##------------------------------------
cars <- Clean_Drive(cars)


head(cars)


```


### Next, Create LM's and run Model_Comparison() to select model and get test its Accuracy


```{r}
standard_lm_function = function(df)
{
  lm_model <- lm(price ~  state + condition + age + odometer + drive + cylinders + med_family_income + med_non_family_income, data = df)
  return (lm_model)
}

standard_lm_log_age = function(df)
{
  lm_model <- lm(price ~ state + condition + log(age + 2) + odometer + drive + cylinders + med_family_income + med_non_family_income, data = df)
  return (lm_model)
}

log_age_log_odometer = function(df)
{
  lm_model <- lm(price ~ state + condition + log(age + 2) + log(odometer + 1) + drive + cylinders + med_family_income + med_non_family_income, data = df)
  return (lm_model)
}


tuple_list =
  list(
    list("Standard LM", standard_lm_function),
    list("Log Age", standard_lm_log_age),
    list("Log Age Log Odometer", log_age_log_odometer)
  )


Model_Comparison(cars, tuple_list)

```


