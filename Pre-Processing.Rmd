---
title: "R Notebook"
output: html_notebook
---
#### Clear Environment
```{r}
rm(list = ls())
```

#### Load Libraries
```{r}
library(tidyverse)
library(dplyr)
library(readxl)
library(stringr)
```
# Create Dataset Files
```{r}
craigslist_file <- 'preprocessing/vehicles.csv'
census_median_income_file <- 'preprocessing/census_median_income_2020.csv'
census_variable_list_file <- 'preprocessing/census_median_income_variable_list.csv'
zcta_mapping_file <- 'preprocessing/zcta_zip_city_map.xlsx'
```


#### Import Datasets
```{r}
cars_df <- read.csv(craigslist_file, na.strings=c("NA", "NULL"), stringsAsFactors = FALSE)
```

```{r}
census_df <- read.csv(census_median_income_file, na.strings=c("NA", "NULL"))
cenus_var_df <- read.csv(census_variable_list_file)
zcta_df <- read_xlsx(zcta_mapping_file)
```

#### Inspect 'cars_df'
```{r}
tail(cars_df, 50)
```
```{r}
print(colnames(cars_df))
```

```{r}
#cars <- cars_df[, names(cars_df) != 'county'] 
cars <- cars_df %>% subset(select = c("id", "region", "price", "year", "manufacturer",
                                      "model", "condition", "cylinders", "fuel",
                                      "odometer", "title_status", "transmission",
                                      "drive", "size", "type", "paint_color",
                                      "description", "state", "lat", "long",
                                      "posting_date"
                                      ))
```

```{r}
num_rows_cars <- dim(cars)[1]
colnames(cars)
```

```{r}
cars[cars == ''] <- NA

cars_num_nas <- data.frame(num_nas = (sapply(cars, function(x){sum(is.na(x))})))
cars_num_nas$percent_nas <- round((cars_num_nas$num_nas / dim(cars)[1]) * 100, 2)
cars_num_nas
```
## Examine and Impute Data for Columns with NA Values

#### 'year' column
```{r}
cars %>% filter(is.na(year) & is.na(description))
```
In most cases, the description column contains the year of the cars; however, there are 68 rows of data that have NA values in BOTH the year and the description columns. We'll drop these rows from the dataset.

```{r}
cars <- cars[!(is.na(cars$year) & is.na(cars$description)), ]
cars %>% filter(is.na(year) & is.na(description))
```
Now let's attempt to parse out the years from the description column and impute them back into the year column. In most cases, the description lists the year first, so we'll grab the first 4 characters from the description column and create a new column 'y' to store them.
```{r}
cars %>% filter(is.na(year))
```
create a list of years to check against when imputing back to the year column.
```{r}

list_of_years = list('2000', '2001', '2002', '2003', '2004', '2005', '2006', '2007', 
                     '2008', '2009', '2010', '2011', '2012', '2013', '2014', '2015', 
                     '2016', '2017', '2018', '2019', '2020', '2021', '2022')
# get the first 4 characters
cars$y <- substr(cars$description, start = 1, stop = 4)

# assign 'y' to 'year' column IF 'year' is NA and the value of 'y' is in "list_of_years"
cars$year <- ifelse(is.na(cars$year), (ifelse(cars$y %in% list_of_years, cars$y, cars$year)), cars$year)
```

Verify that there are no more NA values in the 'year' column
```{r}
cars %>% filter(is.na(year))
```
We can also check to compare the descriptions to the 'year' and 'y' columns after imputation.
```{r}
cars_check_years <- cars %>% subset(select = c('year', 'description', 'y'))
cars_check_years %>% filter(is.na(year))
```
Finally, we'll drop the 'y' column now that we don't need it anymore.
```{r}
cars <- select(cars, -y)
```


#### 'condition' column
```{r}
unique(cars$condition)
```
```{r}
cars$condition[is.na(cars$condition)] <- "unknown"
unique(cars$condition)
```










#### Inspect 'census_df' first 6 rows
```{r}
head(census_df)
```

#### Subset Census to keep the following variables:
- 'NAME'
- 'S1903_C03_015E' 
- 'S1903_C03_034E'
```{r}
census_df <- census_df[-1,]
census <- subset(census_df, select = c('NAME', 'S1903_C03_015E','S1903_C03_034E'))
census <- census %>%
  rename(zcta = NAME,
         median_income_family = S1903_C03_015E,
         median_income_non_family = S1903_C03_034E
         )

summary(census)
```
```{r}
head(census, 50)
```
#### Change Data Types for Median Columns
```{r}
#unique(census$median_income_family)
```
```{r}
census$median_income_family <- gsub('+', '', 
                               gsub('-', NaN, census$median_income_family))
```

```{r}
head(census)
```

```{r}
census$median_income_family <- as.numeric(census$median_income_family)
census$median_income_non_family <- as.numeric(census$median_income_non_family)

census <- census %>% drop_na()

head(census)
```
```{r}
summary(census)
```


```{r}
census <- separate(census, zcta, c("zcta", "zip_code"), ' ')
```

```{r}
head(census)
```
```{r}
census_m <- merge(census, zcta_df, by.x = 'zip_code', by.y = 'ZIP_CODE')
head(census_m)
```
```{r}
census_clean = subset(census_m, select = c("PO_NAME",
                                           "STATE",
                                           "zip_code",
                                           "median_income_family",
                                           "median_income_non_family"))

census_clean = census_clean %>%
  rename("city" = "PO_NAME",
         "state" = "STATE")
```

## SQLite3 Database
```{r}
# Load the RSQLite Library
library(RSQLite)

# Create a connection to our new database, CarsDB.db
# you can check that the .db file has been created on your working directory
conn <- dbConnect(RSQLite::SQLite(), "CarsDB.db")
```

```{r}
# Write the mtcars dataset into a table names mtcars_data
dbWriteTable(conn, "census_data", census_clean)
# List all the tables available in the database
dbListTables(conn)
```

#### Test Query
```{r}
dbGetQuery(conn, "SELECT * FROM census_data")
```

